# Why Are Indices Needed?

The line "The larger the database, the larger the indexes or indices as well." highlights an important aspect of database management. As the volume of data within a database grows, the size of the indexes, which are used to speed up data retrieval operations, also increases.

Indexes are special data structures that store a small portion of the data in a way that makes it quick to search through. They function similarly to an index in a book, allowing the database to find specific rows of data without having to scan the entire table. However, as more data is added to the database, the indexes must also expand to accommodate the new entries. This means that while indexes improve query performance, they also require additional storage space and can impact the overall performance of the database if not managed properly.

In summary, the statement underscores the trade-off between database size and index size, emphasizing the need for careful planning and optimization in database design to maintain efficient data retrieval as the database grows.

## Why Need Index Tables?

The basic answer is to speed up access.

If you look at a traditional database table, it is typically rows and columns of data. For example, consider a sales order table.

### Example: Sales Order Table

This is an example of a sales order header table. Let's say an order has been created:

- **Order Number**: 1
- **Order Date**: 01/01/YYYY
- **User**: User1

Once data is written to this table, most of the time, it is read operations that follow. For instance, you might need to:

- Pull up order number 1.
- Pull up all orders created on the 1st of January by User1.
- Pull up all debit memos (a type of order) created by this user on this date.

### Without Indices

If you take one such query, say a very simple query, how does the database read the record without indices? When you look at the grid like this, it is like a grid in Excel with rows and columns of data. Without indices, the database would have to scan the entire table to find the relevant records, which can be very slow, especially as the table grows larger.

### With Indices

By creating an index on the `order_number` column, the database can quickly locate the specific order without scanning the entire table. Similarly, creating indices on `order_date` and `user` can speed up queries that filter by these columns.

In conclusion, indices are essential for improving the performance of read operations in a database. They allow for quick data retrieval by providing a way to efficiently locate specific rows of data, thus making the database more efficient and responsive.







The provided text explains the necessity of index tables in traditional database systems, particularly focusing on their role in speeding up data access. It begins by describing a typical database table, such as a sales order header table, which contains columns for order number, creation date, and the user who created the order. When data is written to this table, it is often followed by numerous read operations, such as retrieving specific orders based on certain criteria.

Without indices, the database would need to perform a sequential scan of the entire table to find the relevant records. This means that for each query, the database would read each record one by one, checking if it matches the query criteria. This process is inefficient and time-consuming, especially for large tables with millions of records.

To address this inefficiency, indices are created on key columns. An index is essentially a separate table that provides quick pointers to the exact locations of the data in the main table. For example, an index on the order number column allows the database to quickly locate the specific row corresponding to a given order number without scanning the entire table. This significantly speeds up data retrieval.

However, creating and maintaining indices is not without its challenges. While creating an index is straightforward, updating it is resource-intensive. Every time a new record is added to the main table, the corresponding index must also be updated to reflect the new data. This additional operation can become costly, especially if indices are maintained on many columns. Therefore, indices are typically created only on key columns that are frequently accessed randomly.

The text also mentions that indices are not just limited to the main table but are also necessary for aggregate tables. Aggregate tables store cumulative data to avoid expensive dynamic calculations, and they too require indices to optimize data retrieval. This results in a significant increase in the overall database size, as both the main and aggregate tables, along with their indices, contribute to the total storage requirements.

In summary, indices are essential for improving the performance of read operations in a database by providing quick access to specific data. However, they also introduce complexity and additional maintenance overhead, which must be carefully managed to balance performance and resource utilization.








So why need index tables?

The basic answer is to speed up access.

If you look at a traditional database table.

Database table is typically rows and columns of data.

So this is the order number.

This is an example of a sales order table.

Sales order header table, to be precise.

And then we have created date when the order was created.

And then we have a column for who created this data.

And then so on and so forth.

This is the table.

Now, let's say an order has been created.

Order number one, created on 0101 such and such a date.

And then somebody has created user one.

Now.

Once data is being written to this table, most of the time its read operations.

Okay, give me.

Pull up.

Order number one.

Pull up all orders created on the 1st of January by user one.

Pull up all debit memos, which is a type of an order created by this user on this date.

Right.

If you take one such query, say a very simple query.

How does the DB read the record?

Typical without indices.

So when you look at the grid like this, this is like a grid, right?

How it's defined in Excel rows and columns of data.

That's how we tend to visualize it.

And when you go to SC 16, that's how SAP shows it to us.

That's a visual representation.

But inside, inside the system, they are all stored.

Sequentially.

This is the first record.

This is the second record.

This is the third record in memory.

They are stored like that.

Adjacent to one another.

So if you fire a query saying I need.

All orders created by user one Assuming indexes are not there it goes.

Step by step reads each of these records.

So it goes here or reads this record and sees who the user is.

Or is it?

User one No, this is user two.

Okay, skip this record.

Go to the next.

Read this record.

What is the user?

User one Okay.

Make a note of this and then go to the next one.

Read this.

Who is the user?

User one or probably not.

User one.

Skip this record.

Without indices.

This is how data is being retrieved from a database table.

It's all not rows and columns inside memory.

They're all sequential.

One after the other.

That's why we have an index.

Typically order number has an index.

And when there is an index on a table, a separate database table is created.

Just for order number.

And any time you say give me order, number one, it doesn't go to all the rows one by one sequentially

because there is an index.

This.

Index table basically gives you a quick pointer to the exact address where you can find that row.

So if you look at order number 70001, two, three.

This points to the address.

Where exactly that row is located.

That's the beauty of an index.

Lovely, isn't it?

When you have an index on a column, it basically points out to the exact location where.

That data resides.

So basically, an index is used for random access on a column.

The size of this table could be 1 million.

Going sequentially 1 million times for each record is a huge deal.

And that's why indexes are created or indices are created on key columns.

Order number?

Sure.

You don't want to do it on creation date, right?

Date is a range always.

So typically you don't do it.

Maybe order type.

Not even order type.

Maybe user, something like that.

Indices are created on key columns that are accessed randomly most of the time.

Now, why don't you create indices on all columns?

Creating an index is easy.

It just creates one more table.

But updating an index is an expensive operation because every time you create a new record, for example,

a new record is created order number 7000 or 7,000,021.

A new order has come in.

You update this row along with updating the index.

Okay.

7,000,021 and this points out to some row in the memory.

So that's an additional operation that has to be performed every time this table is updated.

So if there are 250 columns in that table back.

If you want to maintain indices on to 50 columns, apart from making an entry in the main table, you

have to update to 50 tables.

That's crazy, isn't it?

So you only maintain indices on key columns, most important ones that are accessed randomly most of

the time.

And then this is not just on the main table back.

All the other aggregate tables also needs indices.

So basically because of this aggregate tables, it results in a huge database size.

And.

The larger the database, the larger the indexes or indices as well.