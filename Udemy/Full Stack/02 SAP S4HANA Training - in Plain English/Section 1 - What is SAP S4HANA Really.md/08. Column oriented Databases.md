The provided text explains the concept of column-oriented databases and contrasts them with traditional row-oriented databases. It begins by describing the traditional row-oriented structure, where data is stored in rows and columns. In this structure, data access is sequential, meaning that to retrieve specific information, the database must scan through each row one by one unless an index is used. This sequential access can be time-consuming, especially for large datasets.

In a row-oriented database, data repetition is common. For example, in a sales order table, fields like "created by" or "order type" may have many repeated values. This repetition leads to inefficiencies in storage and data retrieval. Additionally, row-oriented databases often have many empty columns, which still consume space, further contributing to inefficiencies.

The text then introduces the concept of a column-oriented database, which stores data by columns rather than rows. In a column-oriented database, each column contains all the values for that column, and unique values are stored in a data dictionary. For example, the "order type" column might contain values like "standard order," "credit memo," and "debit memo," with each unique value associated with a list of row numbers where it occurs.

This structure allows for more efficient data retrieval, especially for queries that involve specific columns. For instance, if a query requests all orders where the "order type" is "standard order" and the "customer" is "Walmart," the database can quickly retrieve the relevant row numbers from the data dictionary and perform a set operation to find the intersection of these row numbers. This approach is much faster than scanning through each row sequentially.

The text provides an example to illustrate this concept. It shows how a query in a column-oriented database can quickly retrieve the relevant rows by using the data dictionary and performing set operations. This method is compared to a Venn diagram, where the intersection of sets represents the rows that meet the query criteria.

In summary, the text explains that column-oriented databases offer significant advantages over traditional row-oriented databases by reducing data repetition, efficiently handling empty columns, and enabling faster data retrieval through the use of data dictionaries and set operations. This approach simplifies the overall architecture and improves performance, making it easier to manage and develop database systems.


The provided text explains the concept of column-oriented databases and contrasts them with traditional row-oriented databases. Here are the key points:

1. **Row-Oriented Databases**:
    - **Structure**: Data is stored in rows and columns.
    - **Data Access**: Sequential access, meaning the database must scan through each row one by one unless an index is used.
    - **Inefficiencies**:
        - **Data Repetition**: Common in fields like "created by" or "order type," leading to inefficiencies in storage and data retrieval.
        - **Empty Columns**: Many empty columns still consume space, further contributing to inefficiencies.

2. **Column-Oriented Databases**:
    - **Structure**: Data is stored by columns rather than rows.
    - **Data Dictionary**: Each column contains all the values for that column, and unique values are stored in a data dictionary.
        - Example: The "order type" column might contain values like "standard order," "credit memo," and "debit memo," with each unique value associated with a list of row numbers where it occurs.
    - **Efficiency**:
        - **Data Retrieval**: More efficient, especially for queries that involve specific columns.
        - **Set Operations**: For instance, if a query requests all orders where the "order type" is "standard order" and the "customer" is "Walmart," the database can quickly retrieve the relevant row numbers from the data dictionary and perform a set operation to find the intersection of these row numbers.
        - **Performance**: This approach is much faster than scanning through each row sequentially.

3. **Example**:
    - The text provides an example to illustrate the concept.
    - **Query**: Shows how a query in a column-oriented database can quickly retrieve the relevant rows by using the data dictionary and performing set operations.
    - **Comparison**: This method is compared to a Venn diagram, where the intersection of sets represents the rows that meet the query criteria.

In summary, column-oriented databases offer significant advantages over traditional row-oriented databases by reducing data repetition, efficiently handling empty columns, and enabling faster data retrieval through the use of data dictionaries and set operations. This approach simplifies the overall architecture and improves performance, making it easier to manage and develop database systems.


The second feature of this extremely fast database is column oriented database.

Now, this takes a little bit of time to understand.

So what is a column oriented?

Database.

Traditionally data basically is just a grid of row oriented data.

So these are all the rows.

Divided into so many columns.

So this is row number one.

Order number one.

Order number two.

Order number three.

Row number three, row number four, row number five.

So on and so forth.

And one of the problems with this kind of row oriented structure, like I said, is data access is sequential.

Because in memory, rows are stored like this.

Sequential, they are not stored one below the other, and you can't access data directly on a particular

row.

You need to traverse row by row unless there is an index on that particular column.

So indexes do enable random access, but because of the way the index is created, you can't create

an index on all columns.

So what are the characteristics of row oriented data?

If you take an example of a 16 week sales order data.

And just execute it.

What are the primary characteristics that you see of this data in general?

I'm not talking about specific fields, what they mean.

But what are the characteristics of data that stored in row based database tables like this?

You look at this created by Bollinger.

How many Bollinger are there?

50.

20.

And that's data repetition, isn't it?

There is so much of data that's being repeated again and again and again.

Same thing with document date.

There are orders created on 2201, 1997, and there are ten of them and they are all repeated.

Document status.

See, all of them are see.

So there is a whole bunch of data repetition.

It's also called low cardinality.

Just a technical term for low number of values and high repetition.

If you go white in these columns much further.

You see that this column is empty.

Right.

Keep scrolling further.

And you see there are so many empty columns, right?

Collective number is empty, delivery block is empty, building block is empty.

And they take.

Space.

It has to be specified in the row that this is a blank column.

So even blank columns take space.

So basically enterprise data, apart from being repetitive, is also sparse.

Meaning lots.

Of blanks.

And blanks also take space.

So there's no point in giving space to blank data.

It has to be given because that's how row databases are structured.

And there are unused columns like we have seen.

Unused columns.

So many unused columns.

And how many columns are there in this table?

123 fixed columns.

If you go back.

Go to 11.

Go to back, click on display.

How many columns are there?

126.

Right.

So there are 126.

Columns.

And that's a very wide table.

Right.

So enterprise data is very wide.

So many different columns in a single table.

This is basically.

The pattern of enterprise data.

Now, let me put this in perspective.

Okay.

So let's say there is.

There is an order.

Again, let's take the same database table.

Sales order.

Table.

This is order number.

Order type.

Order!

Date.

Just pulling up some random.

Columns created by.

Then customer.

And then holiday season sale.

So on and so forth.

Now order number one.

Order number two, three, four.

So on.

7,000,001.

7,000,023.

Say there are 10 million orders.

Her.

Here.

How many other types are there?

Maybe there is a standard order.

Most of them are stranded.

Orders may be debit memos here and there.

Or credit memos.

These are different order types.

If you are a consultant, think of framework Order, Standard order and.

Stock transport order.

Utmost.

There are, say, five different order types.

Right.

Same thing.

If you are a consultant, think about process order.

Think about standard production.

Order zero one.

How many are there?

How many variations are there?

4 or 5 of them.

And that data, these three order types are repeated again and again and again.

And same thing with order date.

And how many users are there in your system?

Say 100 users.

Sales users.

And those are the users that get repeated again and again and again 10 million times.

How many customers are there?

Maybe, let's say 10,000 customers.

These 10,000 customers say Walmart.

Target.

Walmart.

Walmart.

Target.

And then this was created by user one User to user 112.

Holiday season.

Let's say the sale is on a holiday season.

Yes.

Yes.

And the rest of the time it's no.

See lots of repetition, lots of blanks.

And because all this data.

In memory is constructed in a linear fashion, one next to the other.

Again, if you want to me to put that in perspective, if you consider this a row, this is order number

one customer.

So and so.

And the next row.

And the next row.

Right.

This is linear.

So get me all orders.

This is a query that somebody is asking.

Get me all orders.

Where customer is Walmart.

An order type is standard order.

Without indices.

How do you do it?

You have to go into each record, check if the customer is Walmart.

Check if the order type is over.

And if yes, make a note of that.

Go to the second row.

Go to the third row.

Scan all the 10 million rows for that year.

So sequential read is very, very time consuming.

Isn't it?

No, this is a raw database.

How about a column oriented database?

How is data stored in a column oriented database?

Think of the same structure.

There are columns, order, number, order type created by customer holiday, isn't it?

Instead of rows.

Think of columns.

This is order number.

Order number is usually unique anyway, so no big deal there.

And then.

This is going to be very long, right?

This is going to be 10 million long.

Makes sense because every number is unique.

This is order type.

And another type.

There is standard order, there is credit memo and there is debit memo say that's it.

Just three different types.

Okay.

And created by.

Is also pretty small.

Created by.

Who created it.

User one.

Two, three, four.

Just for users.

And then customers.

How many of them?

This is going to be a long list.

Say.

10,000.

Right.

Walmart.

Target and then so on.

No repetition, just the basic ones.

And then holiday season.

Holiday season is just yes or blank.

Just two variables.

Right.

These are all the different columns.

This is called as a data dictionary.

Which is basically all the list of unique values in a column.

What are the unique values for order type or CM?

That's it.

What are the list of unique users?

One, two.

Three four.

List of unique customers.

Are encoded in columns called data dictionary.

Now let's represent data in a columnar structure.

Based on the data that we know in row oriented format, because we can understand rows much better,

right?

Because we're used to it.

A row is order number.

Order type.

Order created by.

And then the customer.

Right order number one of type or who has created it.

Siva has created it.

And this is for Walmart.

This is the key screen focus on this screen.

You know, this is where we understand the transition between row oriented thinking and column oriented

thinking.

Order number two.

Debit memo created by Ceva for Target.

Order number three.

The standard order severe again Walmart order number for credit memo created by, say, Smith.

For Walmart.

Order number 5 or 7.

Target six or standard order.

See a target then.

Order number seven.

Order!

Smith.

Uh, Walmart.

All right.

Now, this is how row oriented data structures are created, right?

We understand this better.

This is more or less like an Excel document.

In the column oriented database.

This is how they are represented.

Order type.

Is or debit memo and credit memo.

Right.

Order type or is assuming they're unique numbers here.

You know, I'm assuming order number is unique.

So but there will be an internal unique ID.

But just because it's easy to go by order number.

Or is there in row number one?

Come on.

I'm just going to the left and then row number three.

And then row number five.

Uh, six and seven.

Seven, right?

And then same thing goes for debit memo.

Credit memo.

You just list out all the row numbers that has that particular value.

And user.

How about user?

There is Siva.

That's one unique value.

Smith is the next unique value.

What are all the row numbers that Siva in it?

One, two, three.

One comma, two, comma three.

Then four, not four, five and six.

Five and six.

And how about customer?

Customer is Walmart Target, for example, and Walmart is there in one.

3471347.

And Target is there in

256256.

Now let's try to fire the same query.

Select all the orders where order number equal to standard or.

And customer equal to Walmart.

Okay.

And that's an and operation meaning it has to be both.

Right.

So give me all the row numbers where order number is standard 76531 because I see that here.

Give me all the row numbers where the customer is.

Walmart one three, four, seven.

And it's an end operation, meaning both the conditions have to exist, Right?

So what are the common numbers between these two sets?

There is a one.

There is a tree.

Uh, there's no fall.

There's no fire.

There's no six.

There's a seven.

So row number one, three and seven are the rows where the order number is standard and customer is

Walmart.

You want to quickly check it?

Row number one order is standard Walmart row number three order is standard.

Walmart row number seven order is standard Walmart.

Just to prove things.

Otherwise, go to row number four.

Credit memo.

That's not a standard order or row number five order.

But the customer is not Walmart.

Well, I have oversimplified the way columnar oriented data structures work.

Oversimplified by a huge margin.

But essentially the logic is still the same.

There are data dictionaries that store the unique values by column.

And.

Using something called as an array.

Each unique value stores all the different record IDs.

That it occurs in.

And any time you want to run a query using an end operation or an or operation, essentially it becomes

a set operation.

Like a Venn diagram.

You want to use an end?

Sure.

Put these numbers on the left bin.

Put numbers on the right bin and then do an intersection.

Right.